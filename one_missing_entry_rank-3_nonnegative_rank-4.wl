(* ::Package:: *)

(* ::Section:: *)
(*Functions for computations*)


(* ::Text:: *)
(*Remember to run the following cell before the computations. *)


(* ::Input:: *)
(*(* Compute line between the points {x1,y1} and {x2,y2} *)*)
(*line[{x1_,y1_},{x2_,y2_}]:=If[x1 -x2!=0, (y2-y1)/(x2-x1)*x-y+(y2- (y2-y1)/(x2-x1)*x2),x-x1];*)
(**)
(**)
(*(* See if line l supports the polygon with vertices a1,a2,a3,a4 returns True or False *)*)
(*supp[l_, a1_,a2_,a3_,a4_]:=*)
(*Module[{vals},vals=Block[{x,y},*)
(*{l/. {x->a1[[1]],y->a1[[2]]},*)
(*l/. {x->a2[[1]],y->a2[[2]]},*)
(*l/. {x->a3[[1]],y->a3[[2]]},*)
(*l/. {x->a4[[1]],y->a4[[2]]}}];*)
(*Simplify[(And@@Thread[vals>=0])||(And@@Thread[vals<=0])]*)
(*]*)
(**)
(*(* Given outer vertex q and inner vertices p1,p2,p3,p4, find the two lines q-pi and q-pj such that the lines q-pi and q-pj support the polygon with the inner vertices, returns list with the lines that are supporting the inner polygon *)*)
(*findSupportingLines[q_,a1_,a2_,a3_,a4_]:=Module[{l1,l2,l3,l4,supportingLines},*)
(*l1=line[q,a1];*)
(*l2=line[q,a2];*)
(*l3=line[q,a3];*)
(*l4=line[q,a4];*)
(*supportingLines={};*)
(*If[l1 =!= Nothing &&supp[l1,a1,a2,a3,a4],AppendTo[supportingLines,l1]];*)
(*If[l2 =!= Nothing &&supp[l2,a1,a2,a3,a4],AppendTo[supportingLines,l2]];*)
(*If[l3 =!= Nothing &&supp[l3,a1,a2,a3,a4],AppendTo[supportingLines,l3]];*)
(*If[l4 =!= Nothing &&supp[l4,a1,a2,a3,a4],AppendTo[supportingLines,l4]];*)
(*Return[supportingLines];*)
(*];*)
(**)
(*(* Find the intersection of line l with boundary defined by s1,s2,s3,s4. Returns the intersection point v={x,y} that is not the point q *)*)
(*findIntersectionWithBoundary[l_,s1_,s2_,s3_,s4_,ineqsQ_,q_]:=Module[{linesToCheck,solsubs,v}, *)
(*linesToCheck={s1,s2,s3,s4};*)
(*For[i=1,i<=Length[linesToCheck],i++, solsubs= Solve[l==0 && linesToCheck[[i]]==0 &&ineqsQ, {x,y},Reals]; If[solsubs =!= {}, *)
(*v = {x,y}/.solsubs[[1]]; *)
(*If[v[[1]]!= q[[1]] ||v[[2]]!=q[[2]], Return[v]]*)
(*];*)
(*];*)
(*Nothing*)
(*];*)
(**)
(*(* Check if inner polygon is contained in triangle. INPUT: the edges of triangle and inner vertices. Checks if edges of triangle support inner polygon. Returns True or False *)*)
(*isContained[l1v1_,l1v2_ ,lv1v2_,a1_,a2_,a3_,a4_]:=*)
(*Module[{res},res=supp[l1v1,a1,a2,a3,a4]&&supp[l1v2,a1,a2,a3,a4]&&supp[lv1v2,a1,a2,a3,a4];*)
(*If[res == True,Print["True: This is a triangle nested in between P and Q."],Print["False: This triangle is not nested between P and Q"]];*)
(*Return[res] *)
(*]*)
(**)
(*(* Algorithm for vertex of outer polytope Q. Check if constructed triangle is contained inside Q; if yes, then this is a triangle nested between inner polytope P and Q.*)
(*INPUT: outervertex= outervertex to be checked, ineqsQ = facet inequalities of outer polytope, s1,s2,s3,s4 = boundaries of Q, p1,p2,p3,p4 = vertices of P*)
(*OUTPUT: Prints True or False*)
(*RETURN: the points v1,v2 which are two vertices of the constructed triangle*)
(**)*)
(*CheckIfContainedOuterVertex[outervertex_,ineqsQ_,s1_,s2_,s3_,s4_ ,p1_,p2_,p3_,p4_]:= Module[{supportingLines,v1,v2},*)
(*supportinglines = findSupportingLines[outervertex,p1,p2,p3,p4];*)
(*supportinglines=DeleteDuplicates[supportinglines];*)
(*v1 = findIntersectionWithBoundary[supportinglines[[1]],s1,s2,s3,s4,ineqsQ,outervertex];*)
(*v2 = findIntersectionWithBoundary[supportinglines[[2]],s1,s2,s3,s4,ineqsQ,outervertex];*)
(*l1= line[outervertex,v1];*)
(*l2=line[outervertex,v2];*)
(*l3 = line[v1,v2];*)
(*isContained[l1,l2,l3, p1,p2,p3,p4];*)
(*Return[{v1,v2}]*)
(*];*)
(**)
(*(*Intersection point of the lines l1 and l2*)*)
(*point[l1_,l2_]:=Module[{sol},*)
(*sol = Solve[l1==0&&l2==0,{x,y}, Reals];*)
(*If[sol=!= {},{x,y}/.sol[[1]], Nothing]*)
(*]*)
(**)
(*(* Find the two intersection points of the line l with the boundaries s1,s2,s3,s4, satisfying the inequalities defined by ineqsQ. Returns list of intersection points vi = {xi,yi} *)*)
(*findIntersectionWithBoundaryTwoPoints[l_,s1_,s2_,s3_,s4_,ineqsQ_]:= Module[{linesToCheck,intersections, v,vsubs,res},*)
(*linesToCheck={s1,s2,s3,s4};*)
(*intersections={};*)
(*For[i=1,i<=Length[linesToCheck],i++,*)
(*v=point[l,linesToCheck[[i]]];*)
(*vsubs= {x->v[[1]],y->v[[2]]};*)
(*res = Reduce[ineqsQ/.vsubs];*)
(*If[res==True, AppendTo[intersections, v]]*)
(*];*)
(*Return[intersections]*)
(*];*)
(**)
(*(* Given vertex v, find out whether the line v--innerv1 or v--innerv2 supports the polygon with vertices a1,a2,a3,a4. Returns the line l that supports the polygon. *)*)
(*findSupportingVertexAndLine[v_,innerv1_,innerv2_ ,a1_,a2_,a3_,a4_]:=Module[{innervertices,l},*)
(*innervertices = {innerv1,innerv2};*)
(*For[i=1,i<=Length[innervertices],i++,*)
(*l = line[v,innervertices[[i]]];*)
(*If [supp[l,a1,a2,a3,a4] == True, Return[l]]*)
(*]*)
(*];*)
(**)
(*(* Algorithm for edge of inner polytope P. Check if point v3 contained inside Q; if yes, then conv(v1,v2,v3) is a triangle nested between inner polytope P and Q.*)
(*INPUT: innerv1,innerv2 = vertices of inner polytope spanning the edge we consider, ineqsQ = facet inequalities of outer polytope, s1,s2,s3,s4 = boundaries of Q, p1,p2,p3,p4 = vertices of P*)
(*OUTPUT: Prints True or False*)
(*RETURN: the points v1,v2,v3 which are the vertices of the constructed triangle*)
(**)*)
(*CheckIfContainedInnerEdge[innerv1_,innerv2_, ineqsQ_,s1_,s2_,s3_,s4_, p1_,p2_,p3_,p4_]:=Module[{edge,intersections, v1,v2,l1,l2,remainingVertices,v3,v3subs},*)
(*edge = line[innerv1,innerv2];*)
(*intersections= findIntersectionWithBoundaryTwoPoints[edge,s1,s2,s3,s4,ineqsQ];*)
(*intersections= DeleteDuplicates[intersections];*)
(*v1 = intersections[[1]];*)
(*v2=intersections[[2]];*)
(*remainingVertices = Complement[{p1,p2,p3,p4},{innerv1,innerv2}];*)
(*l1 = findSupportingVertexAndLine[v1,remainingVertices[[1]],remainingVertices[[2]], p1,p2,p3,p4];*)
(*l2 =  findSupportingVertexAndLine[v2,remainingVertices[[1]],remainingVertices[[2]], p1,p2,p3,p4];*)
(*v3 =point[l1,l2];*)
(*v3subs= {x->v3[[1]],y->v3[[2]]};*)
(*Print["The triangle is nested between P and Q: ",Reduce[ineqsQ/.v3subs]];*)
(*Return[{v1,v2,v3}]*)
(*];*)
(**)
(*(* Functions for drawing figures *)*)
(**)
(*DrawNestedPolytopes[q1_,q2_,q3_,q4_,p1_,p2_,p3_,p4_]:= Module[{QVertices,QLabels,PVertices,PLabels},*)
(*QVertices={q1,q2,q3,q4};*)
(*QLabels={Subscript["q",1],Subscript["q",2],Subscript["q",3],Subscript["q",4]};*)
(*PVertices={p1,p3,p2,p4};*)
(*PLabels={Subscript["p",1],Subscript["p",3],Subscript["p",2],Subscript["p",4]};*)
(*Show[Graphics[{*)
(*Style[Polygon[QVertices],Opacity[0.2],Blue],*)
(*Blue,PointSize[Large],Point[QVertices],*)
(*Style[Polygon[PVertices],Opacity[0.2],Red],*)
(*Red,PointSize[Large],Point[PVertices],*)
(*Table[Text[Style[QLabels[[i]],FontSize->12,FontFamily->"Times",FontWeight->"Bold",Blue],*)
(*QVertices[[i]]+If[i==2 ||i==3,{-0.005,-0.006},{-0.005,0.013}]],{i,Length[QVertices]}],*)
(*Table[Text[Style[PLabels[[i]],FontSize->12,FontFamily->"Times",FontWeight->"Bold",Red],PVertices[[i]]+If[i==3 ||i==4,{-0.005,-0.006},{-0.005,0.013}]],{i,Length[PVertices]}]*)
(*		}*)
(*	],*)
(*Axes->True,AxesLabel->{"x","y"},PlotRangePadding->Scaled[0.05],AspectRatio->1*)
(*]*)
(*];*)
(**)
(*DrawConfigurationOuterVertex[outervertex_,v1_,v2_,q1_,q2_,q3_,q4_,p1_,p2_,p3_,p4_]:=Module[{QVertices,QLabels,PVertices,PLabels},*)
(*QVertices={q1,q2,q3,q4};*)
(*QLabels={Subscript["q",1],Subscript["q",2],Subscript["q",3],Subscript["q",4]};*)
(*PVertices={p1,p3,p2,p4};*)
(*PLabels={Subscript["p",1],Subscript["p",3],Subscript["p",2],Subscript["p",4]};*)
(*Show[Graphics[{*)
(*Style[Polygon[QVertices],Opacity[0.2],Blue],*)
(*Blue,PointSize[Large],Point[QVertices],*)
(*Style[Polygon[PVertices],Opacity[0.2],Red],*)
(*Red,PointSize[Large],Point[PVertices],*)
(*Table[Text[Style[QLabels[[i]],FontSize->12,FontFamily->"Times",FontWeight->"Bold",Blue],*)
(*QVertices[[i]]+If[i==2 ||i==3,{-0.005,-0.006},{-0.005,0.013}]],{i,Length[QVertices]}],*)
(*Table[Text[Style[PLabels[[i]],FontSize->12,FontFamily->"Times",FontWeight->"Bold",Red],PVertices[[i]]+If[i==3 ||i==4,{-0.005,-0.006},{-0.005,0.013}]],{i,Length[PVertices]}],*)
(*Dashed,Purple,Line[{outervertex,v1}],Line[{outervertex,v2}],Line[{v1,v2}]}*)
(*	],*)
(*Axes->True,AxesLabel->{"x","y"},PlotRangePadding->Scaled[0.05],AspectRatio->1*)
(*]*)
(*];*)
(**)
(*DrawConfigurationInnerEdge[v1_,v2_,v3_,q1_,q2_,q3_,q4_,p1_,p2_,p3_,p4_]:=Module[{QVertices,QLabels,PVertices,PLabels},*)
(*QVertices={q1,q2,q3,q4};*)
(*QLabels={Subscript["q",1],Subscript["q",2],Subscript["q",3],Subscript["q",4]};*)
(*PVertices={p1,p3,p2,p4};*)
(*PLabels={Subscript["p",1],Subscript["p",3],Subscript["p",2],Subscript["p",4]};*)
(*Show[Graphics[{*)
(*Style[Polygon[QVertices],Opacity[0.2],Blue],*)
(*Blue,PointSize[Large],Point[QVertices],*)
(*Style[Polygon[PVertices],Opacity[0.2],Red],*)
(*Red,PointSize[Large],Point[PVertices],*)
(*Table[Text[Style[QLabels[[i]],FontSize->12,FontFamily->"Times",FontWeight->"Bold",Blue],*)
(*QVertices[[i]]+If[i==2 ||i==3,{-0.005,-0.006},{-0.005,0.013}]],{i,Length[QVertices]}],*)
(*Table[Text[Style[PLabels[[i]],FontSize->12,FontFamily->"Times",FontWeight->"Bold",Red],PVertices[[i]]+If[i==3 ||i==4,{-0.005,-0.006},{-0.005,0.013}]],{i,Length[PVertices]}],*)
(*Dashed,Purple,Line[{v1,v2}],Line[{v1,v3}],Line[{v2,v3}]}],*)
(*Axes->True,AxesLabel->{"x","y"},PlotRangePadding->Scaled[0.05],AspectRatio->1*)
(*]*)
(*];*)


(* ::Section:: *)
(*The code for Example 4.7.*)


(* ::Input:: *)
(*A = {{0,1,2},{1,0,2},{4,1,0},{1,3,0}};*)
(*B = {{0,4,3,2},{4,0,1,1},{4,1,0,4}};*)
(*A . B//MatrixForm*)
(*M1 = A . B;*)


(* ::Subsubsection:: *)
(*Change on entry in A to a negative number*)


(* ::Input:: *)
(*A2 = A;*)
(*A2[[4,3]]=-1;*)
(*M2 = A2 . B;*)


(* ::Subsubsection:: *)
(*Modify factorization*)


(* ::Input:: *)
(*Bcolsums = Total/@Transpose[B];*)
(*Om = {{Bcolsums[[2]],0,0},{Bcolsums[[3]],1,0},{Bcolsums[[4]],0,1}};*)
(*Ahat = A2 . Inverse[Transpose[Om]];*)
(*Ahat//FullSimplify//MatrixForm*)
(*Bhat = Transpose[Om] . B;*)
(*Bhat//Simplify//MatrixForm*)


(* ::Input:: *)
(*(* Outer polytope Q *)*)
(*ineqsQ=And@@Thread[(# . ({1,x,y})>=0)&/@Ahat]//Simplify*)
(**)
(*(* Boundaries of Q*)*)
(*{s1,s2,s3,s4}=Ahat . {1,x,y}//Simplify*)
(**)
(*(* Compute vertices of outer poltyope Q *)*)
(*q1 = {x,y}/.Solve[s1==0&&s4==0, {x,y}][[1]]*)
(*q2 = {x,y}/.Solve[s3==0&&s4==0, {x,y}][[1]]*)
(*q3 = {x,y}/.Solve[s2==0&&s3==0, {x,y}][[1]]*)
(*q4 = {x,y}/.Solve[s1==0&&s2==0, {x,y}][[1]]*)


(* ::Input:: *)
(*Btildepol = Bhat . Inverse[DiagonalMatrix[Bhat[[1,All]]]];*)
(*Btildepol//MatrixForm*)
(*verticesP = Btildepol[[{2,3},All]]//Simplify;*)
(*p1 = verticesP[[All,1]]//Simplify*)
(*p2 = verticesP[[All,2]]*)
(*p3= verticesP[[All,3]]*)
(*p4 = verticesP[[All,4]]*)


(* ::Input:: *)
(*DrawNestedPolytopes[q1,q2,q3,q4,p1,p2,p3,p4]*)


(* ::Section:: *)
(*Computations*)


(* ::Input:: *)
(*(* Vertex q1 *)*)
(*{v1,v2}=CheckIfContainedOuterVertex[q1,ineqsQ,s1,s2,s3,s4, p1,p2,p3,p4];*)
(*DrawConfigurationOuterVertex[q1,v1,v2,q1,q2,q3,q4,p1,p2,p3,p4]*)


(* ::Input:: *)
(*(* Vertex q2 *)*)
(*{v1,v2}=CheckIfContainedOuterVertex[q2,ineqsQ,s1,s2,s3,s4, p1,p2,p3,p4];*)
(*DrawConfigurationOuterVertex[q2,v1,v2,q1,q2,q3,q4,p1,p2,p3,p4]*)


(* ::Input:: *)
(*(* Vertex q3 *)*)
(*{v1,v2}=CheckIfContainedOuterVertex[q3,ineqsQ,s1,s2,s3,s4, p1,p2,p3,p4];*)
(*DrawConfigurationOuterVertex[q3,v1,v2,q1,q2,q3,q4,p1,p2,p3,p4]*)


(* ::Input:: *)
(*(* Vertex q4 *)*)
(*{v1,v2}=CheckIfContainedOuterVertex[q4,ineqsQ,s1,s2,s3,s4, p1,p2,p3,p4];*)
(*DrawConfigurationOuterVertex[q4,v1,v2,q1,q2,q3,q4,p1,p2,p3,p4]*)


(* ::Subsection:: *)
(*Algorithm for inner edges of P.*)


(* ::Input:: *)
(*(* Inner edge 14 *)*)
(*{v1,v2,v3} = CheckIfContainedInnerEdge[p1,p4,ineqsQ,s1,s2,s3,s4,p1,p2,p3,p4]*)
(*DrawConfigurationInnerEdge[v1,v2,v3,q1,q2,q3,q4,p1,p2,p3,p4]*)


(* ::Input:: *)
(*(* Inner edge 13 *)*)
(*{v1,v2,v3} = CheckIfContainedInnerEdge[p1,p3,ineqsQ,s1,s2,s3,s4,p1,p2,p3,p4]*)
(*DrawConfigurationInnerEdge[v1,v2,v3,q1,q2,q3,q4,p1,p2,p3,p4]*)


(* ::Input:: *)
(*(* Inner edge 23 *)*)
(*{v1,v2,v3} = CheckIfContainedInnerEdge[p2,p3,ineqsQ,s1,s2,s3,s4,p1,p2,p3,p4]*)
(*DrawConfigurationInnerEdge[v1,v2,v3,q1,q2,q3,q4,p1,p2,p3,p4]*)


(* ::Input:: *)
(*(* Inner edge 24 *)*)
(*{v1,v2,v3} = CheckIfContainedInnerEdge[p2,p4,ineqsQ,s1,s2,s3,s4,p1,p2,p3,p4]*)
(*DrawConfigurationInnerEdge[v1,v2,v3,q1,q2,q3,q4,p1,p2,p3,p4]*)
