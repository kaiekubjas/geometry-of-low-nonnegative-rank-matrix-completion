(* ::Package:: *)

(* ::Section:: *)
(*Functions*)


(* ::Text:: *)
(*Functions needed for computations. *)


(* ::Input:: *)
(*(* Compute line between the points {x1,y1} and {x2,y2} *)*)
(*line[{x1_,y1_},{x2_,y2_}]:=If[x1 -x2!=0, (y2-y1)/(x2-x1)*x-y+(y2- (y2-y1)/(x2-x1)*x2),x-x1];*)
(**)
(**)
(*(* See if line l supports the polygon with vertices a1,a2,a3,a4 returns True or False *)*)
(*supp[l_, a1_,a2_,a3_,a4_]:=*)
(*Module[{vals},vals=Block[{x,y},*)
(*{l/. {x->a1[[1]],y->a1[[2]]},*)
(*l/. {x->a2[[1]],y->a2[[2]]},*)
(*l/. {x->a3[[1]],y->a3[[2]]},*)
(*l/. {x->a4[[1]],y->a4[[2]]}}];*)
(*Simplify[(And@@Thread[vals>=0])||(And@@Thread[vals<=0])]*)
(*];*)
(**)
(*(* Given outer vertex q and inner vertices p1,p2,p3,p4, find the two lines q-pi and q-pj such that the lines q-pi and q-pj support the polygon with the inner vertices, returns list with the lines that are supporting the inner polygon *)*)
(*findSupportingLines[q_,a1_,a2_,a3_,a4_]:=Module[{l1,l2,l3,l4,supportingLines},*)
(*l1=line[q,a1];*)
(*l2=line[q,a2];*)
(*l3=line[q,a3];*)
(*l4=line[q,a4];*)
(*supportingLines={};*)
(*If[l1 =!= Nothing &&supp[l1,a1,a2,a3,a4],AppendTo[supportingLines,l1]];*)
(*If[l2 =!= Nothing &&supp[l2,a1,a2,a3,a4],AppendTo[supportingLines,l2]];*)
(*If[l3 =!= Nothing &&supp[l3,a1,a2,a3,a4],AppendTo[supportingLines,l3]];*)
(*If[l4 =!= Nothing &&supp[l4,a1,a2,a3,a4],AppendTo[supportingLines,l4]];*)
(*supportingLines = DeleteDuplicates[supportingLines];*)
(*Return[supportingLines];*)
(*];*)
(**)
(*(* Find the intersection of line l with boundary defined by s1,s2,s3,s4. Returns the intersection point v={x,y} that is not the point q *)*)
(*findIntersectionWithBoundary[l_,s1_,s2_,s3_,s4_,ineqsQ_,q_]:=Module[{linesToCheck,solsubs,v}, *)
(*linesToCheck={s1,s2,s3,s4};*)
(*For[i=1,i<=Length[linesToCheck],i++, solsubs= Solve[l==0 && linesToCheck[[i]]==0 &&ineqsQ, {x,y},Reals]; If[solsubs =!= {}, *)
(*v = {x,y}/.solsubs[[1]]; *)
(*If[v[[1]]!= q[[1]] ||v[[2]]!=q[[2]], Return[v]]*)
(*];*)
(*];*)
(*Nothing*)
(*];*)
(**)
(*(* Check if inner polygon is contained in triangle. INPUT: the edges of triangle and inner vertices. Checks if edges of triangle support inner polygon. Returns True or False *)*)
(*isContained[l1v1_,l1v2_ ,lv1v2_,a1_,a2_,a3_,a4_]:=*)
(*Module[{res},res=supp[l1v1,a1,a2,a3,a4]&&supp[l1v2,a1,a2,a3,a4]&&supp[lv1v2,a1,a2,a3,a4];*)
(*If[res == True,Print["True: This is a triangle nested in between P and Q."],Print["False: This triangle is not nested between P and Q"]];*)
(*Return[res] *)
(*];*)
(**)
(**)
(*(*Intersection point of the lines l1 and l2*)*)
(*point[l1_,l2_]:=Module[{sol},*)
(*sol = Solve[l1==0&&l2==0,{x,y}, Reals];*)
(*If[sol=!= {},{x,y}/.sol[[1]], Nothing]*)
(*];*)
(**)
(*triangleCheck[p1_, s1_,s2_,s3_,s4_,q1_,q2_,q3_,q4_ ,ineqsQ_, p1_,p2_,p3_,p4_]:= Module[{l1,l2,l3,v1,v2,v3,v3sol,w, supportingLines,res},*)
(*l1 = line[p1,p4];*)
(*v1 = findIntersectionWithBoundary[l1,s1,s2,s3,s4, ineqsQ,p1];*)
(*supportingLines= findSupportingLines[v1,p1,p2,p3,p4];*)
(*supportingLines=DeleteDuplicates[supportingLines];*)
(*supportingLines = Complement[supportingLines, {l1}];*)
(*l2=supportingLines[[1]];*)
(*ClearAll[{supportingLines}];*)
(*v2 = findIntersectionWithBoundary[l2,s1,s2,s3,s4, ineqsQ,v1];*)
(*supportingLines= findSupportingLines[v2,p1,p2,p3,p4];*)
(*supportingLines=DeleteDuplicates[supportingLines];*)
(*supportingLines = Complement[supportingLines, {l2}];*)
(*l3 = supportingLines[[1]];*)
(*v3sol = Solve[l1==0&&l3==0, {x,y}];*)
(*If[Length[v3sol]==0, res=False,v3 ={x,y}/.v3sol[[1]];*)
(*res = ineqsQ/.{x->v3[[1]],y->v3[[2]]};];*)
(*w = findIntersectionWithBoundary[l3, s1,s2,s3,s4, ineqsQ, v2];*)
(*Return[{res, v1,v2,w}];*)
(*];*)
(**)
(*drawConfiguration[p1_,v1_,v2_,w_, q1_,q2_,q3_,q4_,p2_,p3_,p4_] :=Module[{QVertices,PVertices,QLabels,PLabels},*)
(*QVertices={q1,q2,q3,q4};*)
(*QLabels={Subscript["q",1],Subscript["q",2],Subscript["q",3],Subscript["q",4]};*)
(*PVertices={p2,p3,p4};*)
(*	PLabels={Subscript["p",2],Subscript["p",3],Subscript["p",4]};*)
(*Show[Graphics[{*)
(*Style[Polygon[QVertices],Opacity[0.2],Blue],*)
(*Blue,PointSize[Large],Point[QVertices],*)
(*Style[Polygon[PVertices],Opacity[0.2],Red],*)
(*Red,PointSize[Large],Point[PVertices],*)
(*Table[Text[Style[QLabels[[i]],FontSize->12,FontFamily->"Times",FontWeight->"Bold",Blue],*)
(*QVertices[[i]]+If[i==4,{-0.005,0},If[i==2,{0.005,0.004},{0.005,0}]]],{i,Length[QVertices]}],*)
(*Table[Text[Style[PLabels[[i]],FontSize->12,FontFamily->"Times",FontWeight->"Bold",Red],PVertices[[i]]+Switch[i,1,{-0.005,0},2,{-0.005,0.005},3,{0.005,0.005},_,{0.005,0}]],{i,Length[PVertices]}],*)
(*Red,PointSize[Large],Point[p1],Text[Style[Subscript["p",1],FontSize->12,FontFamily->"Times",FontWeight->"Bold",Red],p1+{0,0.005}],*)
(*Red,PointSize[Large],Point[v1],Text[Style[Subscript["v",1],FontSize->12,FontFamily->"Times",FontWeight->"Bold",Red],v1+{-0.003,0.005}],*)
(*Red,PointSize[Large],Point[v2],Text[Style[Subscript["v",2],FontSize->12,FontFamily->"Times",FontWeight->"Bold",Red],v2+{-0.005,0}],*)
(*Red,PointSize[Large],Point[w],Text[Style["w",FontSize->12,FontFamily->"Times",FontWeight->"Bold",Red],w+{0,-0.005}],*)
(*Dashed,Line[{v1,v2}],*)
(*Line[{w,v2}],*)
(*Line[{v1,p1 }]}],*)
(*Axes->True,AxesLabel->{"x","y"},PlotRange->{{-0.05,0.08},{-0.05,0.08}},AspectRatio->1*)
(*]*)
(*];*)


(* ::Section:: *)
(*Example 5.7*)


(* ::Subsection:: *)
(*Define partial matrix and find rank-3 completion*)


(* ::Input:: *)
(*Mm= {{x,y,m31,0},{5,1,5,9},{1,7,9,3},{9,7,1,3}}//Transpose*)
(*A =   Mm[[All,2;;]];*)
(*B= {{b11,b12,b13},{1,0,0},{0,1,0},{0,0,1}}//Transpose;*)
(*bsol = Solve[Mm[[{3,4},1]]== (A . B)[[{3,4},1]],{b11,b12,b13} ]//Simplify;*)
(*B = B /.bsol[[1]]//Simplify;*)
(*A . B//Simplify//MatrixForm*)


(* ::Input:: *)
(*(*Find bounds for nonnegativity *)*)
(* Reduce[A . B >=0,b11]*)


(* ::Input:: *)
(*(* Substitute b11 -> -t/20 for simplicity *)*)
(*Mm = A . B/.{b11->-(1/20)*t}//Simplify;*)
(*Mm//MatrixForm*)
(*A= A/.{b11->-(1/20)*t}//Simplify;*)
(*B= B/.{b11->-(1/20)*t}//Simplify;*)


(* ::Subsection:: *)
(*Modify factorization*)


(* ::Input:: *)
(*colsums = Total/@Transpose[Mm];*)
(*Om={{colsums[[2]],0,0},{colsums[[3]],1,0},{colsums[[4]],0,1}}//Simplify;*)
(*Ahat =  A . Inverse[Transpose[Om]]//Simplify;*)
(*Bhat = Transpose[Om] . B//Simplify;*)


(* ::Subsection:: *)
(*Define polytopes, take slice x=1*)


(* ::Input:: *)
(*(* Outer polytope Q *)*)
(*ineqsQ=And@@Thread[(# . ({1,x,y})>=0)&/@Ahat]//Simplify*)
(**)
(*(* Boundaries of Q*)*)
(*{s1,s2,s3,s4}=Ahat . {1,x,y}//Simplify*)
(**)
(*(* Compute vertices of outer poltyope Q *)*)
(*q1 = {x,y}/.Solve[s4==0&&s3==0, {x,y}][[1]]*)
(*q2 = {x,y}/.Solve[s1==0&&s4==0, {x,y}][[1]]*)
(*q3 = {x,y}/.Solve[s1==0&&s2==0, {x,y}][[1]]*)
(*q4 = {x,y}/.Solve[s3==0&&s2==0, {x,y}][[1]]*)


(* ::Input:: *)
(*(* Inner polytope, Take slice x=1 *)*)
(*Sm = DiagonalMatrix[colsums]//Simplify;*)
(*Btildepol = Bhat . Transpose[Inverse[Sm]]//Simplify;*)
(*Btildepol//MatrixForm*)
(*verticesP = Btildepol[[{2,3},All]]//Simplify;*)
(*p1 = verticesP[[All,1]]//Simplify*)
(*p2 = verticesP[[All,2]]*)
(*p3= verticesP[[All,3]]*)
(*p4 = verticesP[[All,4]]*)


(* ::Input:: *)
(*(*Find line where the last vertex p1 lies*)*)
(*sol1=Solve[p1[[1]]==x,t];*)
(*lp1 = -y+p1[[2]]/.sol1[[1]]//Simplify*)


(* ::Section:: *)
(*Computations*)


(* ::Subsection:: *)
(*Vertex p1 is a vertex of the triangle*)


(* ::Input:: *)
(*p1=q2;*)
(*{res,v1,v2,w} = triangleCheck[p1,s1,s2,s3,s4,q1,q2,q3,q4,ineqsQ,p1,p2,p3,p4];*)
(*Print["The lines intersect inside Q: ", res]*)
(*drawConfiguration[p1,v1,v2,w,q1,q2,q3,q4,p2,p3,p4 ]*)


(* ::Subsubsection:: *)
(*First critical configuration*)


(* ::Input:: *)
(*p1={3/160,9/160};*)
(*{res,v1,v2,w} = triangleCheck[p1,s1,s2,s3,s4,q1,q2,q3,q4,ineqsQ,p1,p2,p3,p4];*)
(*Print["The lines intersect inside Q: ", res]*)
(*drawConfiguration[p1,v1,v2,w,q1,q2,q3,q4,p2,p3,p4 ]*)


(* ::Subsubsection:: *)
(*Second critical configuration*)


(* ::Input:: *)
(*p1={13/800,47/800};*)
(*{res,v1,v2,w} = triangleCheck[p1,s1,s2,s3,s4,q1,q2,q3,q4,ineqsQ,p1,p2,p3,p4];*)
(*Print["The lines intersect inside Q: ", res]*)
(*drawConfiguration[p1,v1,v2,w,q1,q2,q3,q4,p2,p3,p4 ]*)


(* ::Subsubsection:: *)
(*Third critical configuration*)


(* ::Input:: *)
(*p1=point[line[q4,p4],lp1];*)
(*{res,v1,v2,w} = triangleCheck[p1,s1,s2,s3,s4,q1,q2,q3,q4,ineqsQ,p1,p2,p3,p4];*)
(*Print["The lines intersect inside Q: ", res]*)
(*drawConfiguration[p1,v1,v2,w,q1,q2,q3,q4,p2,p3,p4 ]*)


(* ::Subsubsection:: *)
(*Fourth critical configuration*)


(* ::Input:: *)
(*p1=q1;*)
(*{res,v1,v2,w} = triangleCheck[p1,s1,s2,s3,s4,q1,q2,q3,q4,ineqsQ,p1,p2,p3,p4];*)
(*Print["The lines intersect inside Q: ", res]*)
(*drawConfiguration[p1,v1,v2,w,q1,q2,q3,q4,p2,p3,p4 ]*)


(* ::Subsection:: *)
(*Edge of triangle is an edge of Q.*)


(* ::Input:: *)
(*(* Considering outer edge q1q2 as edge *)*)
(*lq1p4 =line[q1,p4];*)
(*lq2p3 = line[q2,p3];*)
(*v =point[lq1p4,lq2p3];*)
(*(* Check if v is inside Q *)*)
(*ineqsQ/.{x->v[[1]],y->v[[2]]}//Simplify*)


(* ::Input:: *)
(*(* This code is for drawing the figure *)*)
(**)
(*(*Vertices of outer polytope Q*)*)
(*qVertices={q1,q2,q3,q4};*)
(*qLabels={Subscript["q",1],Subscript["q",2],Subscript["q",3],Subscript["q",4]};*)
(**)
(*(*Vertices of the inner polygon P*)*)
(*pVertices={p2,p3,p4};*)
(*pLabels={Subscript["p",2],Subscript["p",3],Subscript["p",4]};*)
(**)
(*Show[Graphics[{*)
(*(*Draw outer polygon Q*)*)
(*Style[Polygon[qVertices],Opacity[0.2],Blue],*)
(*(*Mark the vertices of inner polygon P*)*)
(*Blue,PointSize[Large],Point[qVertices],*)
(**)
(*(*Draw inner polygon P*)*)
(*Style[Polygon[pVertices],Opacity[0.2],Red],*)
(*(*Mark the vertices of inner polygon P*)*)
(*Red,PointSize[Large],Point[pVertices],*)
(**)
(*(*Add labels to outer polygon Q vertices*)*)
(*Table[*)
(*Text[Style[qLabels[[i]],FontSize->12,FontFamily->"Times",FontWeight->"Bold",Blue],*)
(*qVertices[[i]]+If[i==4,{-0.005,0},{0.005,0}]],{i,Length[qVertices]}],*)
(**)
(*(*Add labels to inner polygon P vertices*)Table[Text[Style[pLabels[[i]],FontSize->12,FontFamily->"Times",FontWeight->"Bold",Red],pVertices[[i]]+Switch[i,1,{-0.005,0},2,{-0.005,0.005},3,{0.005,0.005},_,{0.005,0}]],{i,Length[pVertices]}],*)
(**)
(*(*Draw dashed lines for the given equations*)*)
(*Red,Dashed,Line[{q1,q2}],*)
(*Line[{v,q1}],*)
(*Line[{v,q2}]*)
(*}*)
(*],*)
(*Axes->True,AxesLabel->{"x","y"},PlotRange->{{-0.05,0.08},{-0.05,0.08}},AspectRatio->1*)
(*]*)
(**)
