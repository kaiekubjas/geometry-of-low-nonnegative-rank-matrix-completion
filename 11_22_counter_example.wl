(* ::Package:: *)

(* ::Section:: *)
(*Functions for computations*)


(* ::Text:: *)
(*Remember to run the following cell before the computations. *)


(* ::Input:: *)
(*(* Compute line between the points {x1,y1} and {x2,y2} *)*)
(*line[{x1_,y1_},{x2_,y2_}]:=If[x1 -x2!=0, (y2-y1)/(x2-x1)*x-y+(y2- (y2-y1)/(x2-x1)*x2),x-x1];*)
(**)
(**)
(*(* See if line l supports the polygon with vertices a1,a2,a3,a4 returns True or False *)*)
(*supp[l_, a1_,a2_,a3_,a4_]:=*)
(*Module[{vals},vals=Block[{x,y},*)
(*{l/. {x->a1[[1]],y->a1[[2]]},*)
(*l/. {x->a2[[1]],y->a2[[2]]},*)
(*l/. {x->a3[[1]],y->a3[[2]]},*)
(*l/. {x->a4[[1]],y->a4[[2]]}}];*)
(*Simplify[(And@@Thread[vals>=0])||(And@@Thread[vals<=0])]*)
(*]*)
(**)
(*(* Given outer vertex q and inner vertices p1,p2,p3,p4, find the two lines q-pi and q-pj such that the lines q-pi and q-pj support the polygon with the inner vertices, returns list with the lines that are supporting the inner polygon *)*)
(*findSupportingLines[q_,a1_,a2_,a3_,a4_]:=Module[{l1,l2,l3,l4,supportingLines},*)
(*l1=line[q,a1];*)
(*l2=line[q,a2];*)
(*l3=line[q,a3];*)
(*l4=line[q,a4];*)
(*supportingLines={};*)
(*If[l1 =!= Nothing &&supp[l1,a1,a2,a3,a4],AppendTo[supportingLines,l1]];*)
(*If[l2 =!= Nothing &&supp[l2,a1,a2,a3,a4],AppendTo[supportingLines,l2]];*)
(*If[l3 =!= Nothing &&supp[l3,a1,a2,a3,a4],AppendTo[supportingLines,l3]];*)
(*If[l4 =!= Nothing &&supp[l4,a1,a2,a3,a4],AppendTo[supportingLines,l4]];*)
(*Return[supportingLines];*)
(*];*)
(**)
(*(* Find the intersection of line l with boundary defined by s1,s2,s3,s4. Returns the intersection point v={x,y} that is not the point q *)*)
(*findIntersectionWithBoundary[l_,s1_,s2_,s3_,s4_,ineqsQ_,q_]:=Module[{linesToCheck,solsubs,v}, *)
(*linesToCheck={s1,s2,s3,s4};*)
(*For[i=1,i<=Length[linesToCheck],i++, solsubs= Solve[l==0 && linesToCheck[[i]]==0 &&ineqsQ, {x,y},Reals]; If[solsubs =!= {}, *)
(*v = {x,y}/.solsubs[[1]]; *)
(*If[v[[1]]!= q[[1]] ||v[[2]]!=q[[2]], Return[v]]*)
(*];*)
(*];*)
(*Nothing*)
(*];*)
(**)
(*(* Check if inner polygon is contained in triangle. INPUT: the edges of triangle and inner vertices. Checks if edges of triangle support inner polygon. Returns True or False *)*)
(*isContained[l1v1_,l1v2_ ,lv1v2_,a1_,a2_,a3_,a4_]:=*)
(*Module[{res},res=supp[l1v1,a1,a2,a3,a4]&&supp[l1v2,a1,a2,a3,a4]&&supp[lv1v2,a1,a2,a3,a4];*)
(*If[res == True,Print["True: This is a triangle nested in between P and Q."],Print["False: This triangle is not nested between P and Q"]];*)
(*Return[res] *)
(*]*)
(**)
(*(* Algorithm for vertex of outer polytope Q. Check if constructed triangle is contained inside Q; if yes, then this is a triangle nested between inner polytope P and Q.*)
(*INPUT: outervertex= outervertex to be checked, ineqsQ = facet inequalities of outer polytope, s1,s2,s3,s4 = boundaries of Q, p1,p2,p3,p4 = vertices of P*)
(*OUTPUT: Prints True or False*)
(*RETURN: the points v1,v2 which are two vertices of the constructed triangle*)
(**)*)
(*CheckIfContainedOuterVertex[outervertex_,ineqsQ_,s1_,s2_,s3_,s4_ ,p1_,p2_,p3_,p4_]:= Module[{supportingLines,v1,v2},*)
(*supportinglines = findSupportingLines[outervertex,p1,p2,p3,p4];*)
(*supportinglines=DeleteDuplicates[supportinglines];*)
(*v1 = findIntersectionWithBoundary[supportinglines[[1]],s1,s2,s3,s4,ineqsQ,outervertex];*)
(*v2 = findIntersectionWithBoundary[supportinglines[[2]],s1,s2,s3,s4,ineqsQ,outervertex];*)
(*l1= line[outervertex,v1];*)
(*l2=line[outervertex,v2];*)
(*l3 = line[v1,v2];*)
(*isContained[l1,l2,l3, p1,p2,p3,p4];*)
(*Return[{v1,v2}]*)
(*];*)
(**)
(*(*Intersection point of the lines l1 and l2*)*)
(*point[l1_,l2_]:=Module[{sol},*)
(*sol = Solve[l1==0&&l2==0,{x,y}, Reals];*)
(*If[sol=!= {},{x,y}/.sol[[1]], Nothing]*)
(*]*)
(**)
(*(* Find the two intersection points of the line l with the boundaries s1,s2,s3,s4, satisfying the inequalities defined by ineqsQ. Returns list of intersection points vi = {xi,yi} *)*)
(*findIntersectionWithBoundaryTwoPoints[l_,s1_,s2_,s3_,s4_,ineqsQ_]:= Module[{linesToCheck,intersections, v,vsubs,res},*)
(*linesToCheck={s1,s2,s3,s4};*)
(*intersections={};*)
(*For[i=1,i<=Length[linesToCheck],i++,*)
(*v=point[l,linesToCheck[[i]]];*)
(*vsubs= {x->v[[1]],y->v[[2]]};*)
(*res = Reduce[ineqsQ/.vsubs];*)
(*If[res==True, AppendTo[intersections, v]]*)
(*];*)
(*Return[intersections]*)
(*];*)
(**)
(*(* Given vertex v, find out whether the line v--innerv1 or v--innerv2 supports the polygon with vertices a1,a2,a3,a4. Returns the line l that supports the polygon. *)*)
(*findSupportingVertexAndLine[v_,innerv1_,innerv2_ ,a1_,a2_,a3_,a4_]:=Module[{innervertices,l},*)
(*innervertices = {innerv1,innerv2};*)
(*For[i=1,i<=Length[innervertices],i++,*)
(*l = line[v,innervertices[[i]]];*)
(*If [supp[l,a1,a2,a3,a4] == True, Return[l]]*)
(*]*)
(*];*)
(**)
(*(* Algorithm for edge of inner polytope P. Check if point v3 is contained inside Q; if yes, then conv(v1,v2,v3) is a triangle nested between inner polytope P and Q.*)
(*INPUT: innerv1,innerv2 = vertices of inner polytope spanning the edge we consider, ineqsQ = facet inequalities of outer polytope, s1,s2,s3,s4 = boundaries of Q, p1,p2,p3,p4 = vertices of P*)
(*OUTPUT: Prints True or False*)
(*RETURN: the points v1,v2,v3 which are the vertices of the constructed triangle*)
(**)*)
(*CheckIfContainedInnerEdge[innerv1_,innerv2_, ineqsQ_,s1_,s2_,s3_,s4_, p1_,p2_,p3_,p4_]:=Module[{edge,intersections, v1,v2,l1,l2,remainingVertices,v3,v3subs},*)
(*edge = line[innerv1,innerv2];*)
(*intersections= findIntersectionWithBoundaryTwoPoints[edge,s1,s2,s3,s4,ineqsQ];*)
(*intersections= DeleteDuplicates[intersections];*)
(*v1 = intersections[[1]];*)
(*v2=intersections[[2]];*)
(*remainingVertices = Complement[{p1,p2,p3,p4},{innerv1,innerv2}];*)
(*l1 = findSupportingVertexAndLine[v1,remainingVertices[[1]],remainingVertices[[2]], p1,p2,p3,p4];*)
(*l2 =  findSupportingVertexAndLine[v2,remainingVertices[[1]],remainingVertices[[2]], p1,p2,p3,p4];*)
(*v3 =point[l1,l2];*)
(*v3subs= {x->v3[[1]],y->v3[[2]]};*)
(*Print["The triangle is nested between P and Q: ",Reduce[ineqsQ/.v3subs]];*)
(*Return[{v1,v2,v3}]*)
(*];*)
(**)
(**)
(*DrawConfigurationOuterVertex[outervertex_,v1_,v2_,q1_,q2_,q3_,q4_,p1_,p2_,p3_,p4_]:=Module[{QVertices,QLabels,PVertices,PLabels},*)
(*QVertices={q1,q2,q3,q4};*)
(*QLabels={Subscript["q",1],Subscript["q",2],Subscript["q",3],Subscript["q",4]};*)
(*PVertices={p1,p3,p4};*)
(*PLabels={Subscript["p",1],Subscript["p",3],Subscript["p",4]};*)
(*Show[Graphics[{*)
(*Style[Polygon[QVertices],Opacity[0.2],Blue],*)
(*Blue,PointSize[Medium],Point[QVertices],*)
(*Style[Polygon[PVertices],Opacity[0.2],Red],*)
(*Red,PointSize[Medium],Point[PVertices],*)
(**)
(*Point[p2],Text[Style[Subscript["p",2],FontSize->12,FontFamily->"Times",FontWeight->"Bold",Red],p2+{-0.02,0.005}],*)
(*Table[*)
(*Text[Style[QLabels[[i]],FontSize->12,FontFamily->"Times",FontWeight->"Bold",Blue],*)
(*QVertices[[i]]+If[i==4,{0.02,0.03},If[i==1,{-0.02,-0.01},If[i==2,{-0.03,0.02},{-0.03,0.04}]]]],{i,Length[QVertices]}],*)
(*Table[Text[Style[PLabels[[i]],FontSize->12,FontFamily->"Times",FontWeight->"Bold",Red],PVertices[[i]]+If[i==1,{0.005,-0.03},If[i==2,{0.005,0.04},{0.04,0}]] ],{i,Length[PVertices]}],*)
(*Dashed, Line[{p2,p1}], Line[{p2,p3}],*)
(*Purple,*)
(*Line[{outervertex,v1}],Line[{outervertex,v2}], Line[{v1,v2}]}],*)
(*Axes->True,AxesLabel->{"x","y"},PlotRangePadding->Scaled[0.05],AspectRatio->1*)
(*]*)
(*]*)
(**)
(*DrawConfigurationInnerEdge[v1_,v2_,v3_,q1_,q2_,q3_,q4_,p1_,p2_,p3_,p4_]:=Module[{QVertices,QLabels,PVertices,PLabels},*)
(*QVertices={q1,q2,q3,q4};*)
(*QLabels={Subscript["q",1],Subscript["q",2],Subscript["q",3],Subscript["q",4]};*)
(*PVertices={p1,p3,p4};*)
(*PLabels={Subscript["p",1],Subscript["p",3],Subscript["p",4]};*)
(*Show[Graphics[{*)
(*Style[Polygon[QVertices],Opacity[0.2],Blue],*)
(*Blue,PointSize[Medium],Point[QVertices],*)
(*Style[Polygon[PVertices],Opacity[0.2],Red],*)
(*Red,PointSize[Medium],Point[PVertices],*)
(*Point[p2],Text[Style[Subscript["p",2],FontSize->12,FontFamily->"Times",FontWeight->"Bold",Red],p2+{-0.02,0.005}],*)
(*Table[*)
(*Text[Style[QLabels[[i]],FontSize->12,FontFamily->"Times",FontWeight->"Bold",Blue],*)
(*QVertices[[i]]+If[i==4,{0.02,0.03},If[i==1,{-0.02,-0.01},If[i==2,{-0.03,0.02},{-0.03,0.04}]]]],{i,Length[QVertices]}],*)
(*Table[Text[Style[PLabels[[i]],FontSize->12,FontFamily->"Times",FontWeight->"Bold",Red],PVertices[[i]]+If[i==1,{0.005,-0.03},If[i==2,{0.005,0.04},{0.04,0}]] ],{i,Length[PVertices]}],*)
(*Dashed, Line[{p2,p1}], Line[{p2,p3}],*)
(*Purple,*)
(*Line[{v1,v2}],Line[{v1,v3}],Line[{v2,v3}]}],*)
(*Axes->True,AxesLabel->{"x","y"},PlotRangePadding->Scaled[0.05],AspectRatio->1*)
(*]*)
(*]*)


(* ::Section:: *)
(*Example 5.9*)


(* ::Subsection:: *)
(*Define partial matrix and find rank-3 completion*)


(* ::Input:: *)
(*Mm={{x,1,112/425,1},{1/10,b1,1/100,7/20},{1/10,10,9/10,3/5},{4/5,9,9/100,1/20}};*)
(*A = {{a11,a12,a13},{1,0,0},{0,1,0},{0,0,1}};*)
(*B = {{1/10,b1,1/100,7/20},{1/10,10,9/10,3/5},{4/5,9,9/100,1/20}};*)
(**)
(*sol1 = Solve[(A . B)[[1,{3,4}]]==Mm[[1,{3,4}]],{a11,a12}];*)
(*A2 = A/.sol1[[1]];*)
(*sol2=Solve[(A2 . B)[[1,2]]==Mm[[1,2]],a13];*)
(*A3 = A2/.sol2[[1]]//Simplify;*)
(*Mm =A3 . B;*)


(* ::Input:: *)
(*(*Find bounds for nonnegativity *)*)
(*boundsforM  = Reduce[Mm>=0,b1]*)


(* ::Subsection:: *)
(*Define polytopes*)


(* ::Input:: *)
(*(* Define inner polytope P by taking slice x+y+z=1 *)*)
(*B1 = B[[All,1]];*)
(*B2=B[[All,2]];*)
(*B3 =  B[[All,3]];*)
(*B4 =  B[[All,4]];*)
(*l1sol = Solve[l1*(B1[[1]]+B1[[2]]+B1[[3]])==1,l1];*)
(*p1 = l1*B1/.l1sol[[1]];*)
(*l2sol = Solve[l2*(B2[[1]]+B2[[2]]+B2[[3]])==1,l2];*)
(*p2 = l2*B2/.l2sol[[1]];*)
(*l3sol=Solve[l3*(B3[[1]]+B3[[2]]+B3[[3]])==1,l3];*)
(*p3 = l3*B3/.l3sol[[1]];*)
(*l4sol = Solve[l4*(B4[[1]]+B4[[2]]+B4[[3]])==1,l4];*)
(*p4 = l4*B4/.l4sol[[1]];*)
(**)
(*(* Vertices of P *)*)
(*p1= {p1[[1]],p1[[2]]}*)
(*p2= {p2[[1]],p2[[2]]}*)
(*p3= {p3[[1]],p3[[2]]}*)
(*p4= {p4[[1]],p4[[2]]}*)
(**)
(*(* Define inner vertex p2 for values t = 0 and t = 4284/9959 *)*)
(*p20 = p2/.{b1->boundsforM[[1]]};*)
(*p2c =  p2/.{b1->boundsforM[[-1]]};*)


(* ::Input:: *)
(*(* Define outer polytope Q by taking slice x+y+z=1 *)*)
(*ineqsQ=And@@Thread[(# . ({x,y,-x-y+1})>=0)&/@A3];*)
(**)
(*BoundariesQ= A3 . {x,y,-x-y+1};*)
(*{s1,s2,s3,s4}=BoundariesQ;*)
(*q3 = point[s2,s4];*)
(*q4 = point[s3,s4];*)
(**)
(*(* Define the outer polytopes Q_t for values t = 0 and t = 4284/9959 *)*)
(*ineqsQ0 = ineqsQ/.{b1->boundsforM[[1]]};*)
(*q10= point[s1,s3]/.{b1->boundsforM[[1]]};*)
(*q20 = point[s1,s2]/.{b1->boundsforM[[1]]};*)
(**)
(*(* c = 4284/9959 *)*)
(*ineqsQc = ineqsQ/.{b1->boundsforM[[-1]]};*)
(*q1c= point[s1,s3]/.{b1->boundsforM[[-1]]};*)
(*q2c = point[s1,s2]/.{b1->boundsforM[[-1]]};*)


(* ::Input:: *)
(*(* This code is for the figure *)*)
(**)
(*(*Vertices of outer polygon Q0*)*)
(*Q0Vertices={q10,q20,q3,q4};*)
(*Q0Labels={Subscript["q",1],Subscript["q",2],Subscript["q",3],Subscript["q",4]};*)
(**)
(*(*Vertices of outer polygon Q1*)*)
(*QcVertices={q1c,q2c,q3,q4};*)
(*QcLabels={Subscript["qc",1],Subscript["qc",2],Subscript["q",3],Subscript["q",4]};*)
(**)
(*(*Vertices of the inner polygon P*)*)
(*PVertices={p1,p3,p4};*)
(*PLabels={Subscript["p",1],Subscript["p",3],Subscript["p",4]};*)
(**)
(*Show[Graphics[{*)
(*(*Draw outer polygon Q0*)*)
(*Style[Polygon[Q0Vertices],Opacity[0.2],Blue],*)
(*Blue,PointSize[Medium],Point[Q0Vertices],*)
(**)
(*(*Draw outer polygon Qc*)*)
(*Style[Polygon[QcVertices],Opacity[0.3],Blue],*)
(*Blue,PointSize[Medium],Point[QcVertices],*)
(**)
(*Red,*)
(*Point[p2c],Text[Style[Subscript["p","c"],FontSize->12,FontFamily->"Times",FontWeight->"Bold",Red],p2c+{0.02,0.005}],*)
(*Point[p20],Text[Style[Subscript["p",0],FontSize->12,FontFamily->"Times",FontWeight->"Bold",Red],p20+{-0.04,-0.005}],*)
(**)
(*(*Draw inner polygon P*)*)
(*Style[Polygon[PVertices],Opacity[0.2],Red],*)
(*(*Mark the vertices of inner polygon P*)*)
(*Red,PointSize[Medium],Point[PVertices],*)
(**)
(*(*Add labels to outer polygon Q vertices*)*)
(*Table[*)
(*Text[Style[Q0Labels[[i]],FontSize->12,FontFamily->"Times",FontWeight->"Bold",Blue],*)
(*Q0Vertices[[i]]+If[i==4,{0.02,0.03},If[i==1,{-0.02,-0.01},If[i==2,{-0.03,0.02},{-0.03,0.04}]]]],{i,Length[Q0Vertices]}],*)
(**)
(*Table[*)
(*Text[Style[QcLabels[[i]],FontSize->12,FontFamily->"Times",FontWeight->"Bold",Blue],*)
(*QcVertices[[i]]+If[i==1,{0,-0.02},{-0.03,0.02}]],{i,Length[QcVertices]-2}],*)
(**)
(*(*Add labels to inner polygon P vertices*)Table[Text[Style[PLabels[[i]],FontSize->12,FontFamily->"Times",FontWeight->"Bold",Red],PVertices[[i]]+If[i==1,{0.005,-0.03},If[i==2,{0.005,0.04},{0.04,0}]] ],{i,Length[PVertices]}],*)
(* *)
(*Red, Line[{p20,p2c}],*)
(*Dashed, Line[{p20,p1}], Line[{p20,p3}],Line[{p20,p1}],Line[{p2c,p3}],Line[{p2c,p1}]*)
(*}*)
(*],*)
(*Axes->True,AxesLabel->{"x","y"},PlotRange->{{-0.05,1.1},{-0.05,1.1}},AspectRatio->1*)
(*]*)


(* ::Section:: *)
(*Computations*)


(* ::Subsection:: *)
(*Algorithm for vertices of outer polytope*)


(* ::Input:: *)
(*(*Define s1 with value t = 0 *)*)
(*s1= s1 /.{b1->0};*)


(* ::Input:: *)
(*(* Vertex q1 *)*)
(*{v1,v2}=CheckIfContainedOuterVertex[q10,ineqsQ0,s1,s2,s3,s4, p1,p2c,p3,p4];*)


(* ::Input:: *)
(*DrawConfigurationOuterVertex[q10,v1,v2,q10,q20,q3,q4,p1,p2c,p3,p4]*)


(* ::Input:: *)
(*(* Vertex q2 *)*)
(*{v1,v2}=CheckIfContainedOuterVertex[q20,ineqsQ0,s1,s2,s3,s4, p1,p2c,p3,p4];*)


(* ::Input:: *)
(*DrawConfigurationOuterVertex[q20,v1,v2,q10,q20,q3,q4,p1,p2c,p3,p4]*)


(* ::Input:: *)
(*(* Vertex q3 *)*)
(*{v1,v2}=CheckIfContainedOuterVertex[q3,ineqsQ0,s1,s2,s3,s4, p1,p2c,p3,p4];*)


(* ::Input:: *)
(*(*In here changing ImageSize->Full shows that p2 is not contained in the triangle *)*)
(*DrawConfigurationOuterVertex[q3,v1,v2,q10,q20,q3,q4,p1,p2c,p3,p4]*)


(* ::Input:: *)
(*(* Vertex q4 *)*)
(*{v1,v2}=CheckIfContainedOuterVertex[q4,ineqsQ0,s1,s2,s3,s4, p1,p2c,p3,p4];*)


(* ::Input:: *)
(*DrawConfigurationOuterVertex[q4,v1,v2,q10,q20,q3,q4,p1,p2c,p3,p4]*)


(* ::Subsection:: *)
(*Algorithm for edges of inner polytope*)


(* ::Input:: *)
(*(* inner edge 12 *)*)
(*{v1,v2,v3}=CheckIfContainedInnerEdge[p1,p2c, ineqsQ0, s1,s2,s3,s4,p1,p2c,p3,p4];*)


(* ::Input:: *)
(*(* This code is for a figure to illustrate the above computations *)*)
(**)
(*(*Vertices of outer polygon Q0*)*)
(*Q0Vertices={q10,q20,q3,q4};*)
(*Q0Labels={Subscript["q",01],Subscript["q",02],Subscript["q",3],Subscript["q",4]};*)
(**)
(*(*Vertices of the inner polygon P*)*)
(*PVertices={p1,p3,p4};*)
(*PLabels={Subscript["p",1],Subscript["p",3],Subscript["p",4]};*)
(**)
(*Show[Graphics[{*)
(*(*Draw outer polygon Q0*)*)
(*Style[Polygon[Q0Vertices],Opacity[0.2],Blue],*)
(*Blue,PointSize[Medium],Point[Q0Vertices],*)
(**)
(*(*Draw inner polygon P*)*)
(*Style[Polygon[PVertices],Opacity[0.2],Red],*)
(*(*Mark the vertices of inner polygon P*)*)
(*Red,PointSize[Medium],Point[PVertices],*)
(**)
(*Point[p2c],Text[Style[Subscript["p",2],FontSize->12,FontFamily->"Times",FontWeight->"Bold",Red],p2c+{-0.02,0.005}],*)
(*(*Add labels to outer polygon Q vertices*)*)
(*Table[*)
(*Text[Style[Q0Labels[[i]],FontSize->12,FontFamily->"Times",FontWeight->"Bold",Blue],*)
(*Q0Vertices[[i]]+If[i==4,{0.02,0.03},If[i==1,{-0.02,-0.01},If[i==2,{-0.03,0.02},{-0.03,0.04}]]]],{i,Length[Q0Vertices]}],*)
(*(*Add labels to inner polygon P vertices*)Table[Text[Style[PLabels[[i]],FontSize->12,FontFamily->"Times",FontWeight->"Bold",Red],PVertices[[i]]+If[i==1,{0.005,-0.03},If[i==2,{0.005,0.04},{0.04,0}]] ],{i,Length[PVertices]}],*)
(*Dashed, Line[{p2c,p1}], Line[{p2c,p3}],*)
(*Purple,*)
(*Line[{v3,{6151/464435,458284/464435}}],Line[{v3,{4854317/13339385,8485068/13339385}}], Line[{{6151/464435,458284/464435},{4854317/13339385,8485068/13339385}}],Line[{v1,v2}]*)
(*}*)
(*],*)
(*Axes->True,AxesLabel->{"x","y"},PlotRangePadding->Scaled[0.05],AspectRatio->1*)
(*]*)


(* ::Input:: *)
(*(* inner edge 23 *)*)
(*{v1,v2,v3}=CheckIfContainedInnerEdge[p2c,p3, ineqsQ0, s1,s2,s3,s4,p1,p2c,p3,p4];*)


(* ::Input:: *)
(*(* This code is for a figure to illustrate the above computations *)*)
(**)
(*(*Vertices of outer polygon Q0*)*)
(*Q0Vertices={q10,q20,q3,q4};*)
(*Q0Labels={Subscript["q",01],Subscript["q",02],Subscript["q",3],Subscript["q",4]};*)
(**)
(*(*Vertices of the inner polygon P*)*)
(*PVertices={p1,p3,p4};*)
(*PLabels={Subscript["p",1],Subscript["p",3],Subscript["p",4]};*)
(**)
(*Show[Graphics[{*)
(*(*Draw outer polygon Q0*)*)
(*Style[Polygon[Q0Vertices],Opacity[0.2],Blue],*)
(*Blue,PointSize[Medium],Point[Q0Vertices],*)
(**)
(*(*Draw inner polygon P*)*)
(*Style[Polygon[PVertices],Opacity[0.2],Red],*)
(*(*Mark the vertices of inner polygon P*)*)
(*Red,PointSize[Medium],Point[PVertices],*)
(**)
(*Point[p2c],Text[Style[Subscript["p",2],FontSize->12,FontFamily->"Times",FontWeight->"Bold",Red],p2c+{-0.02,0.005}],*)
(*(*Add labels to outer polygon Q vertices*)*)
(*Table[*)
(*Text[Style[Q0Labels[[i]],FontSize->12,FontFamily->"Times",FontWeight->"Bold",Blue],*)
(*Q0Vertices[[i]]+If[i==4,{0.02,0.03},If[i==1,{-0.02,-0.01},If[i==2,{-0.03,0.02},{-0.03,0.04}]]]],{i,Length[Q0Vertices]}],*)
(*(*Add labels to inner polygon P vertices*)Table[Text[Style[PLabels[[i]],FontSize->12,FontFamily->"Times",FontWeight->"Bold",Red],PVertices[[i]]+If[i==1,{0.005,-0.03},If[i==2,{0.005,0.04},{0.04,0}]] ],{i,Length[PVertices]}],*)
(*Dashed, Line[{p2c,p1}], Line[{p2c,p3}],*)
(*Purple,*)
(*Line[{v1,v2}],Line[{v1,{854708889/5965707616,0}}],Line[{v2,{275447/315283,0}}]*)
(*}*)
(*],*)
(*Axes->True,AxesLabel->{"x","y"},PlotRangePadding->Scaled[0.05],AspectRatio->1*)
(*]*)


(* ::Input:: *)
(*(* inner edge 34 *)*)
(*{v1,v2,v3}=CheckIfContainedInnerEdge[p3,p4, ineqsQ0, s1,s2,s3,s4,p1,p2c,p3,p4];*)


(* ::Input:: *)
(*DrawConfigurationInnerEdge[v1,v2,v3,q10,q20,q3,q4,p1,p2c,p3,p4]*)


(* ::Input:: *)
(*(* inner edge 14 *)*)
(*{v1,v2,v3}=CheckIfContainedInnerEdge[p1,p4, ineqsQ0, s1,s2,s3,s4,p1,p2c,p3,p4];*)


(* ::Input:: *)
(*DrawConfigurationInnerEdge[v1,v2,v3,q10,q20,q3,q4,p1,p2c,p3,p4]*)
